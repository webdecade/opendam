<?php


/**
 * Skeleton subclass for performing query and update operations on the 'iptc' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Thu Jul  7 11:47:47 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class IptcPeer extends BaseIptcPeer {

	public static $iptcTable = array(
		"2#005" => "Title",
		"2#010" => "Urgency",
		"2#015" => "Category",
		"2#020" => "Supplemnetal Categories",
		"2#025" => "Keywords",
		"2#040" => "Special Instructions",
		"2#055" => "Date Created",
		"2#080" => "By-line",
		"2#085" => "By-line Title",
		"2#090" => "City",
		"2#095" => "Province/State",
		"2#101" => "Country/Primary Location Name",
		"2#103" => "Original Transmission Reference",
		"2#105" => "Headline",
		"2#110" => "Credit",
		"2#115" => "Source",
		"2#116" => "Copyright Notice",
		"2#120" => "Caption/Abstract",
		"2#122" => "Writer/Editor"
	);

	public static function setIptc($iptc_data, $file_id, $column = null)
	{
		if(is_array($iptc_data))
		{
			foreach($iptc_data as $key => $value)
			{
				if(is_array($value) && count($value) > 1)
					self::setIptc(implode(", ", $value), $file_id, self::$iptcTable[$key]);
				else
				{
					if((array_key_exists($key, self::$iptcTable) && !$column) || $column)
					{
						$val = (is_array($value) ? $value[0] : $value);

						$iptc = new Iptc();
						$iptc->setTitle($column ? $column : self::$iptcTable[$key]);
						$iptc->setValue(mb_detect_encoding($val, mb_detect_order(), true) == "UTF-8" ? $val : utf8_encode($val));
						$iptc->setFileId($file_id);

						$iptc->save();
					}
				}
			}
		}
		elseif($column)
		{
			$iptc = new Iptc();
			$iptc->setTitle($column);
			$iptc->setValue(mb_detect_encoding($iptc_data, mb_detect_order(), true) == "UTF-8" ? $iptc_data : utf8_encode($iptc_data));
			$iptc->setFileId($file_id);

			$iptc->save();
		}
	}

	public static function getAllTags($file_id)
	{
		$c = new Criteria();
		$c->add(self::FILE_ID, $file_id);
		$c->addAscendingOrderByColumn(self::TITLE);
		$iptcs = self::doSelect($c);
		return $iptcs;
	}

	public static function getTag($tag_name, $file_id)
	{
		$c = new Criteria();
		$c->add(self::FILE_ID, $file_id);
		$c->add(self::TITLE, $tag_name);
		return self::doSelectOne($c);
	}

	public static function getDistinctTitle()
	{
		$c = new Criteria();
		$c->clearSelectColumns();
		$c->addSelectColumn(self::TITLE);
		$c->setDistinct();
		$c->addAscendingOrderByColumn(self::TITLE);

		$stm = self::doSelectStmt($c);
		$result = $stm->fetchAll();

		$titles_array = array();
		foreach($result as $title)
			$titles_array[$title["TITLE"]] = $title["TITLE"];

		return $titles_array;
	}

	public static function search($engine, $criteria)
	{
		$ids = array();

		$engine->setMode(SPH_MATCH_EXTENDED);
		$engine->setIndex("iptcs");
		$ids = $engine->search($criteria);

		return empty($ids) ? Array() : $ids;
	}

	public static function writeIptc($iptc, $path)
	{
		/*$cmd = "cat ".escapeshellarg($path);
		$tmp = $path.".".time();

		foreach($iptc as $tag => $string)
		{
			if(array_key_exists($tag, self::$iptcTable))
			{
				switch(strtolower(self::$iptcTable[$tag]))
				{
					case "writer/editor": $cmd = "exiftool -iptc:author=".escapeshellarg($string)." -overwrite_original ".escapeshellarg($path); break;
					case "title": $cmd = "exiftool -iptc:title=".escapeshellarg($string)." -overwrite_original ".escapeshellarg($path); break;
					case "keywords":
					{
						$keywords = explode(";", $string);

						if(count($keywords) > 1)
							;
						else
						{
							$temp = explode(',', $string);

							if(count($temp) > count($keywords))
								$keywords = $temp;
						}

						if(is_array($keywords))
						{
							$cmd .= " | exiftool";
							foreach($keywords as $substring)
								$cmd .= " -iptc:".strtolower(self::$iptcTable[$tag])."+=".escapeshellarg($substring);
						}
						else
							$cmd .= " | exiftool -iptc:".strtolower(self::$iptcTable[$tag])."+=".escapeshellarg($string);

						$cmd .= " -> ".escapeshellarg($tmp);
					}
					break;
				}

				shell_exec($cmd);
				@rename($tmp, $path);
			}
		}*/
	}
} // IptcPeer
